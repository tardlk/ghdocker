name: 同步 Docker 镜像 → ghcr.io
permissions:
  packages: write
  contents: write
on:
  workflow_dispatch:
    inputs:
      images:
        description: "要同步的 Docker 镜像列表，格式为 '镜像1:标签1,镜像2:标签2,镜像3:标签3'"
        required: true
        default: ""
      ghcr_names:
        description: "对应的同步后的镜像名称列表，格式为 '名称1,名称2,名称3'，如果某个镜像不需要指定名称，则用逗号填充，例如 ',,my-image' 表示第三个镜像同步后名称为 my-image，前两个自动提取"
        required: false
        default: ""
      change_tag_to_latest:
        description: "同步后是否将镜像标签改为 latest (是/否)"
        required: true
        type: choice
        options:
          - "是"
          - "否"
        default: "是"
jobs:
  docker-image-sync:
    runs-on: ubuntu-latest
    steps:
      - name: 安装依赖工具
        run: sudo apt-get update && sudo apt-get install -y jq skopeo
      
      - name: 检出仓库
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 设置 GHCR_USER 环境变量
        id: set_ghcr_user
        run: echo "GHCR_USER=${{ github.actor }}" >> $GITHUB_ENV
      
      - name: 登录到 GitHub 容器注册表
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ env.GHCR_USER }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 设置 Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: 同步镜像并更新 README（语法修复版）
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git pull --rebase

          # --- 1. 初始化基础模板（确保 example.yaml 存在）---
          mkdir -p docker-compose
          if [ ! -f "docker-compose/example.yaml" ]; then
            echo "⚠️ 未找到 docker-compose/example.yaml，自动生成基础模板"
            cat > docker-compose/example.yaml << 'EOF'
          version: '3.8'
          services:
            app:
              image: ghcr.io/USER/IMAGE:TAG
              container_name: app-container
              restart: unless-stopped
              # 可按需添加以下配置
              # volumes:
              #   - ./data:/app/data
              # ports:
              #   - "8080:8080"
              # environment:
              #   - TZ=Asia/Shanghai
          EOF
            sed -i "s/ghcr.io\/USER/ghcr.io\/${{ env.GHCR_USER }}/g" docker-compose/example.yaml
          fi

          # --- 2. 镜像同步核心逻辑（支持嵌套目录+重试机制）---
          NEW_ROWS_DATA=""
          UNIQUE_SEPARATOR="%%%"
          TABLE_TITLE="### 已同步的 Docker 镜像"
          # 提取 README 中已存在的源镜像，避免重复同步
          existing_source_images=$(awk '
            $0 == "'"${TABLE_TITLE}"'" { in_table=1; next }
            in_table {
              if (/^\| [0-9]/) { 
                match($0, /\| *[^|]+ *\| *([^|]+) *\|/);
                if (RSTART) { print substr($0, RSTART, RLENGTH) }
              }
              if (!/^\|/ && !/^$/) { in_table=0 }
            }
          ' README.md | sed -e 's/|//g' -e 's/^[ \t]*//;s/[ \t]*$//')

          # 解析输入参数为数组
          IFS=',' read -r -a image_array <<< "${{ inputs.images }}"
          IFS=',' read -r -a ghcr_name_array <<< "${{ inputs.ghcr_names }}"

          for i in "${!image_array[@]}"; do
            full_image=$(echo "${image_array[$i]}" | xargs)
            if [ -z "$full_image" ]; then continue; fi

            # 跳过已存在的镜像
            if echo "$existing_source_images" | grep -qFx "$full_image"; then
              echo "ℹ️ 镜像 $full_image 已存在于 README.md，跳过。"
              continue
            fi
            
            echo "--------------------------------------------------"
            echo "===== 开始处理 $full_image ====="
            # 拆分镜像名和标签（默认标签为 latest）
            current_image=$(echo "$full_image" | cut -d':' -f1)
            current_tag=$(echo "$full_image" | cut -s -d':' -f2); [ -z "$current_tag" ] && current_tag="latest"
            # 确定目标标签（alpine 标签特殊保留）
            target_tag="$current_tag"
            if [[ "$current_tag" =~ "alpine" ]]; then
              target_tag="alpine"
            elif [ "${{ inputs.change_tag_to_latest }}" == "是" ]; then
              target_tag="latest"
            fi
            # 标记同步状态
            sync_status="✔️"
            if [ "$current_tag" != "latest" ] && [ "$target_tag" != "alpine" ]; then
              sync_status="❌"
            fi

            # 确定目标 GHCR 镜像名（未指定则自动提取）
            current_ghcr_name="${ghcr_name_array[$i]}"
            if [ -z "$current_ghcr_name" ]; then 
              IMAGE_NAME=$(basename "$current_image")
            else 
              IMAGE_NAME="$current_ghcr_name"
            fi
            SOURCE_IMAGE_URI="docker://$current_image:$current_tag"
            TARGET_IMAGE_URI="docker://ghcr.io/${{ env.GHCR_USER }}/$IMAGE_NAME:$target_tag"

            # --- 带重试的 skopeo 同步 ---
            echo "源镜像: $SOURCE_IMAGE_URI"
            echo "目标镜像: $TARGET_IMAGE_URI"
            retry_count=2
            sync_success=false
            for ((attempt=1; attempt<=retry_count; attempt++)); do
              if skopeo copy --all "$SOURCE_IMAGE_URI" "$TARGET_IMAGE_URI"; then
                sync_success=true
                echo "✅ 镜像同步成功（第 $attempt 次尝试）"
                break
              else
                if [ $attempt -lt $retry_count ]; then
                  echo "⚠️ 第 $attempt 次同步失败，5 秒后重试..."
                  sleep 5
                else
                  echo "❌ 镜像同步失败（已重试 $retry_count 次）"
                  echo "   排查方向：1. 源镜像是否存在 2. 网络是否稳定 3. 源镜像是否需要认证"
                fi
              fi
            done
            if [ "$sync_success" != true ]; then
              continue
            fi

            # --- 生成 compose 文件（支持嵌套目录）---
            compose_file_path="docker-compose/$IMAGE_NAME.yaml"
            # 提取父目录并创建（如 docker-compose/louislam）
            compose_dir=$(dirname "$compose_file_path")
            mkdir -p "$compose_dir"
            # 复制模板并替换镜像地址（用 | 分隔符避免 / 冲突）
            cp docker-compose/example.yaml "$compose_file_path"
            sed -i "s|ghcr.io\/${{ env.GHCR_USER }}\/IMAGE:TAG|$TARGET_IMAGE_URI|g" "$compose_file_path"
            echo "✅ 已生成 compose 文件：$compose_file_path"

            # --- 准备 README 表格数据 ---
            pull_cmd="ghcr.io/${{ env.GHCR_USER }}/$IMAGE_NAME"
            if [ "$target_tag" != "latest" ]; then
              pull_cmd="$pull_cmd:$target_tag"
            fi
            pull_cmd="\`$pull_cmd\`"
            # 生成 compose 文件的 GitHub 链接
            compose_file="[yaml](https://github.com/${{ github.repository }}/blob/main/$compose_file_path)"
            # 记录 UTC 更新时间
            update_time=$(date -u "+%Y-%m-%d %H:%M:%S")
            # 拼接表格行数据（确保 5 列完整）
            new_line_data="${full_image}${UNIQUE_SEPARATOR}${pull_cmd}${UNIQUE_SEPARATOR}${compose_file}${UNIQUE_SEPARATOR}${sync_status}${UNIQUE_SEPARATOR}${update_time}"
            NEW_ROWS_DATA+="${new_line_data}\n"
          done

          # 无新镜像时退出
          if [ -z "$NEW_ROWS_DATA" ]; then
            echo "--------------------------------------------------"
            echo "ℹ️ 没有新的镜像被添加，无需更新 README.md。"
            exit 0
          fi

          # --- 3. 更新 README 表格（修复语法错误：补充闭合双引号）---
          echo "--------------------------------------------------"
          echo "开始更新 README.md..."
          # 提取已有表格行
          existing_rows=$(awk '
            $0 == "'"${TABLE_TITLE}"'" { in_table=1; next }
            in_table {
              if (/^\| [0-9]/) { print }
              if (!/^\|/ && !/^$/) { in_table=0 }
            }
          ' README.md)
          # 合并新旧行并按镜像名排序（不区分大小写）
          sorted_table_rows=$(
            {
              # 清理已有行的序号
              echo "$existing_rows" | sed 's/^| [0-9]\{1,\} *|/|/'
              # 解析新行数据
              echo -e "$NEW_ROWS_DATA" | sed '/^$/d' | awk -F"${UNIQUE_SEPARATOR}" '{
                printf("| %s | %s | %s | %s | %s |\n", $1, $2, $3, $4, $5)
              }'
            } | awk -F'|' '
              {
                key = $3;
                gsub(/`/, "", key);
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", key);
                sub(/.*\/|:[^:]*$/, "", key);  # 提取镜像名作为排序键
                print key "@@@" $0;
              }
            ' | sort -f | sed 's/^.*@@@//' | awk '
              BEGIN{count=1} {printf("| %-3d %s\n", count++, $0)}  # 重新添加序号
            '
          )

          # 生成新表格（关键修复：给表头行补充结尾的闭合双引号）
          {
            echo "${TABLE_TITLE}"
            echo ""
            echo "|   | 源镜像 | pull 镜像 | docker-compose | 同步 | 更新时间（UTC） |"
            echo "|----|----------|-----------|----------------|------|----------------|"  # 此处补充了闭合双引号
            echo "$sorted_table_rows"
          } > new_table.tmp

          # 替换 README 中的旧表格
          awk '
            BEGIN { replaced=0 }
            $0 == "'"${TABLE_TITLE}"'" && !replaced {
              while ((getline line < "new_table.tmp") > 0) { print line }
              close("new_table.tmp");
              replaced=1;
              skipping=1;
              next;
            }
            skipping {
              if (!/^\|/ && !/^$/) { skipping=0 } else { next }
            }
            { print }
          ' README.md > README.tmp && mv README.tmp README.md
          rm new_table.tmp

          # --- 4. 提交更改到仓库 ---
          git add README.md docker-compose/
          if git diff --staged --quiet; then
            echo "ℹ️ 没有新的镜像或文件变更可提交。"
          else
            git commit -m "chore(sync): 同步新镜像 $full_image 并更新 README"
            git push
            echo "✅ 所有变更已提交到仓库"
          fi
