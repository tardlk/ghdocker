name: 同步 Docker 镜像 → ghcr.io
permissions:
  packages: write
  contents: write
on:
  workflow_dispatch:
    inputs:
      images:
        description: "要同步的 Docker 镜像列表，格式为 '镜像1:标签1,镜像2:标签2,镜像3:标签3'"
        required: true
        default: ""
      ghcr_names:
        description: "对应的同步后的镜像名称列表，格式为 '名称1,名称2,名称3'，如果某个镜像不需要指定名称，则用逗号填充，例如 ',,my-image' 表示第三个镜像同步后名称为 my-image，前两个自动提取"
        required: false
        default: ""
      change_tag_to_latest:
        description: "同步后是否将镜像标签改为 latest (是/否)"
        required: true
        type: choice
        options:
          - "是"
          - "否"
        default: "是"
jobs:
  docker-image-sync:
    runs-on: ubuntu-latest
    steps:
      - name: 安装依赖工具
        run: sudo apt-get update && sudo apt-get install -y jq skopeo
      
      - name: 检出仓库
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 设置 GHCR_USER 环境变量
        id: set_ghcr_user
        run: echo "GHCR_USER=${{ github.actor }}" >> $GITHUB_ENV
      
      - name: 登录到 GitHub 容器注册表
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ env.GHCR_USER }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 设置 Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: 同步镜像并更新 README（修复语法报错版）
        run: |
          # 初始化 Git 配置
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git pull --rebase

          # --- 1. 初始化基础模板（确保 example.yaml 存在）---
          mkdir -p docker-compose
          if [ ! -f "docker-compose/example.yaml" ]; then
            echo "⚠️ 未找到 docker-compose/example.yaml，自动生成基础模板"
            cat > docker-compose/example.yaml << 'EOF'
          version: '3.8'
          services:
            app:
              image: ghcr.io/USER/IMAGE:TAG
              container_name: app-container
              restart: unless-stopped
              # 可按需添加以下配置
              # volumes:
              #   - ./data:/app/data
              # ports:
              #   - "8080:8080"
              # environment:
              #   - TZ=Asia/Shanghai
          EOF
            sed -i "s/ghcr.io\/USER/ghcr.io\/${{ env.GHCR_USER }}/g" docker-compose/example.yaml
          fi

          # --- 2. 镜像同步核心逻辑（支持嵌套目录+重试机制）---
          NEW_ROWS_DATA=""
          UNIQUE_SEPARATOR="%%%"
          TABLE_TITLE="### 已同步的 Docker 镜像"
          
          # 提取 README 中已存在的源镜像（严格匹配，避免重复同步）
          existing_source_images=$(awk '
            $0 == "'"${TABLE_TITLE}"'" { in_table=1; next }
            in_table {
              if (/^\| [0-9]/) { 
                # 提取第2列（源镜像）内容，清理空格
                match($0, /\| *[^|]+ *\| *([^|]+) *\|/);
                if (RSTART) {
                  src_img = substr($0, RSTART+RLENGTH-length(substr($0, RSTART, RLENGTH))+2, RLENGTH-4);
                  gsub(/^[ \t]*|[ \t]*$/, "", src_img);
                  print src_img
                }
              }
              if (!/^\|/ && !/^$/) { in_table=0 }
            }
          ' README.md)

          # 解析输入参数为数组
          IFS=',' read -r -a image_array <<< "${{ inputs.images }}"
          IFS=',' read -r -a ghcr_name_array <<< "${{ inputs.ghcr_names }}"

          for i in "${!image_array[@]}"; do
            full_image=$(echo "${image_array[$i]}" | xargs)
            if [ -z "$full_image" ]; then continue; fi

            # 跳过已存在的镜像
            if echo "$existing_source_images" | grep -qFx "$full_image"; then
              echo "ℹ️ 镜像 $full_image 已存在于 README.md，跳过。"
              continue
            fi
            
            echo "--------------------------------------------------"
            echo "===== 开始处理 $full_image ====="
            # 拆分镜像名和标签（默认标签为 latest）
            current_image=$(echo "$full_image" | cut -d':' -f1)
            current_tag=$(echo "$full_image" | cut -s -d':' -f2); [ -z "$current_tag" ] && current_tag="latest"
            # 确定目标标签（alpine 标签特殊保留）
            target_tag="$current_tag"
            if [[ "$current_tag" =~ "alpine" ]]; then
              target_tag="alpine"
            elif [ "${{ inputs.change_tag_to_latest }}" == "是" ]; then
              target_tag="latest"
            fi
            # 标记同步状态（严格按源标签判定）
            sync_status="✔️"
            if [ "$current_tag" != "latest" ] && [ "$target_tag" != "alpine" ]; then
              sync_status="❌"
            fi

            # 确定目标 GHCR 镜像名（未指定则自动提取，支持嵌套路径）
            current_ghcr_name="${ghcr_name_array[$i]}"
            if [ -z "$current_ghcr_name" ]; then 
              # 提取完整镜像路径（如 "louislam/dockge" 保留嵌套结构）
              IMAGE_NAME=$(echo "$current_image" | awk -F'/' '{if(NF>1) print $0; else print $1}')
            else 
              IMAGE_NAME="$current_ghcr_name"
            fi
            SOURCE_IMAGE_URI="docker://$current_image:$current_tag"
            TARGET_IMAGE_URI="docker://ghcr.io/${{ env.GHCR_USER }}/$IMAGE_NAME:$target_tag"

            # --- 带重试的 skopeo 同步 ---
            echo "源镜像: $SOURCE_IMAGE_URI"
            echo "目标镜像: $TARGET_IMAGE_URI"
            retry_count=2
            sync_success=false
            for ((attempt=1; attempt<=retry_count; attempt++)); do
              if skopeo copy --all "$SOURCE_IMAGE_URI" "$TARGET_IMAGE_URI"; then
                sync_success=true
                echo "✅ 镜像同步成功（第 $attempt 次尝试）"
                break
              else
                if [ $attempt -lt $retry_count ]; then
                  echo "⚠️ 第 $attempt 次同步失败，5 秒后重试..."
                  sleep 5
                else
                  echo "❌ 镜像同步失败（已重试 $retry_count 次）"
                  echo "   排查方向：1. 源镜像是否存在 2. 网络是否稳定 3. 源镜像是否需要认证"
                fi
              fi
            done
            if [ "$sync_success" != true ]; then
              continue
            fi

            # --- 生成 compose 文件（支持嵌套目录）---
            compose_file_path="docker-compose/$IMAGE_NAME.yaml"
            # 提取父目录并创建（如 docker-compose/louislam）
            compose_dir=$(dirname "$compose_file_path")
            mkdir -p "$compose_dir"
            # 复制模板并替换镜像地址（用 | 分隔符避免 / 冲突）
            cp docker-compose/example.yaml "$compose_file_path"
            sed -i "s|ghcr.io\/${{ env.GHCR_USER }}\/IMAGE:TAG|${TARGET_IMAGE_URI#docker://}|g" "$compose_file_path"
            echo "✅ 已生成 compose 文件：$compose_file_path"

            # --- 准备 README 表格数据（标准化格式）---
            pull_cmd="ghcr.io/${{ env.GHCR_USER }}/$IMAGE_NAME"
            if [ "$target_tag" != "latest" ]; then
              pull_cmd="$pull_cmd:$target_tag"
            fi
            pull_cmd="\`$pull_cmd\`"
            # 生成 compose 文件的 GitHub 链接
            compose_file="[yaml](https://github.com/${{ github.repository }}/blob/main/$compose_file_path)"
            # 记录 UTC 更新时间
            update_time=$(date -u "+%Y-%m-%d %H:%M:%S")
            # 拼接表格行数据（确保 5 列完整，清理空格）
            new_line_data="$(echo "$full_image" | xargs)${UNIQUE_SEPARATOR}$(echo "$pull_cmd" | xargs)${UNIQUE_SEPARATOR}$(echo "$compose_file" | xargs)${UNIQUE_SEPARATOR}$(echo "$sync_status" | xargs)${UNIQUE_SEPARATOR}$(echo "$update_time" | xargs)"
            NEW_ROWS_DATA+="${new_line_data}\n"
          done

          # 无新镜像时退出
          if [ -z "$NEW_ROWS_DATA" ]; then
            echo "--------------------------------------------------"
            echo "ℹ️ 没有新的镜像被添加，无需更新 README.md。"
            exit 0
          fi

          # --- 3. 更新 README 表格（核心修复：兼容 mawk 语法）---
          echo "--------------------------------------------------"
          echo "开始更新 README.md..."
          # 提取已有表格行（仅保留有效数据行）
          existing_rows=$(awk '
            $0 == "'"${TABLE_TITLE}"'" { in_table=1; next }
            in_table {
              if (/^\| [0-9]/) { print }
              if (!/^\|/ && !/^$/) { in_table=0 }
            }
          ' README.md)

          # 合并新旧行并按镜像名排序（修复版：解决 mawk 语法报错+格式错乱）
          sorted_table_rows=$(
            {
              # 清理已有行：保留第2-6列，标准化格式
              echo "$existing_rows" | awk -F'|' '
                BEGIN{OFS="|"}
                {
                  for (i=2; i<=6; i++) { gsub(/^[ \t]+|[ \t]+$/, "", $i) }
                  if ($2 != "") { printf("| %s | %s | %s | %s | %s |\n", $2, $3, $4, $5, $6) }
                }
              # 处理新行：强制5列格式，清理空格
              echo -e "$NEW_ROWS_DATA" | sed '/^$/d' | awk -F"${UNIQUE_SEPARATOR}" '
                BEGIN{OFS="|"}
                {
                  for (i=1; i<=5; i++) { gsub(/^[ \t]+|[ \t]+$/, "", $i) }
                  printf("| %s | %s | %s | %s | %s |\n", $1, $2, $3, $4, $5)
                }
              '
            } | awk -F'|' '
              # 提取排序键：按镜像名（兼容嵌套路径，兼容所有 awk 版本）
              {
                pull_col = $3;
                gsub(/`/, "", pull_col);
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", pull_col);
                # 步骤1：从右往左取最后两个 "/" 之间的内容（如 "a/b/c:d" → "b/c:d"）
                img_part = pull_col;
                n = split(img_part, arr, "/");
                if (n >= 2) {
                  img_part = arr[n-1] "/" arr[n];
                }
                # 步骤2：去掉标签（如 "b/c:d" → "b/c"）
                gsub(/:[^:]+$/, "", img_part);
                # 步骤3：去掉前缀 USER/（如 "louislam/dockge" → "dockge"）
                gsub(/^[^\/]+\//, "", img_part);
                # 若提取失败，用原 pull_col 作为键
                img_key = (img_part == "") ? pull_col : img_part;
                print tolower(img_key) "@@@" $0;
              }
            ' | sort | sed 's/^.*@@@//' | awk '
              # 重新添加序号，标准化间距（与表头对齐）
              BEGIN{count=1; OFS="|"}
              {
                printf("| %-2d | %s\n", count++, substr($0, 3))
              }
            '
          )

          # 生成新表格（标准化表头+内容）
          {
            echo "${TABLE_TITLE}"
            echo ""
            echo "|   | 源镜像                     | pull 镜像                              | docker-compose                                                                 | 同步 | 更新时间（UTC）       |"
            echo "|----|----------------------------|---------------------------------------|--------------------------------------------------------------------------------|------|-----------------------|"
            echo "$sorted_table_rows"
          } > new_table.tmp

          # 替换 README 中的旧表格
          awk '
            BEGIN { replaced=0 }
            $0 == "'"${TABLE_TITLE}"'" && !replaced {
              while ((getline line < "new_table.tmp") > 0) { print line }
              close("new_table.tmp");
              replaced=1;
              skipping=1;
              next;
            }
            skipping {
              if (!/^\|/ && !/^$/) { skipping=0 } else { next }
            }
            { print }
          ' README.md > README.tmp && mv README.tmp README.md
          rm new_table.tmp

          # --- 4. 表格格式校验（避免错乱提交）---
          echo "🔍 校验 README 表格格式..."
          # 正常行应包含 7 个 "|"（对应 5 列数据+序号列）
          invalid_rows=$(grep -n "|" README.md | awk -F'|' 'NF != 7' | wc -l)
          if [ "$invalid_rows" -gt 0 ]; then
            echo "❌ 发现 $invalid_rows 行表格格式错误（缺失列），终止提交。"
            grep -n "|" README.md | awk -F'|' 'NF != 7'
            exit 1
          fi

          # --- 5. 提交更改到仓库 ---
          git add README.md docker-compose/
          if git diff --staged --quiet; then
            echo "ℹ️ 没有新的镜像或文件变更可提交。"
          else
            # 提交信息包含所有新同步的镜像
            new_images=$(echo -e "$NEW_ROWS_DATA" | sed '/^$/d' | cut -d"${UNIQUE_SEPARATOR}" -f1 | tr '\n' ' ')
            git commit -m "chore(sync): 同步新镜像 $new_images 并更新 README"
            git push
            echo "✅ 所有变更已提交到仓库"
          fi
